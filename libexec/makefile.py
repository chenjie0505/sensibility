#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

# Copyright 2017 Eddie Antonio Santos <easantos@ualberta.ca>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import io
import os
from contextlib import redirect_stdout
from typing import Any, Dict, List, NamedTuple, Set, Union
from pprint import pprint
from pathlib import Path

StrPath = Union[str, os.PathLike]


class Command:
    def __init__(self, bin: str, *args: str, **kwargs) -> None:
        self.bin = bin
        self.arguments: List[str] = []
        self._add_arguments(*args, **kwargs)

    def __call__(self, *args, **kwargs) -> 'Command':
        return self.copy()._add_arguments(*args, **kwargs)

    def _add_arguments(self, *args: str, **kwargs: Any) -> 'Command':
        def generate_kwargs():
            for option, value in kwargs.items():
                if value is False:
                    continue
                elif len(option) == 1:
                    yield '-' + option
                else:
                    yield '--' + option.replace('_', '-')
                # Values that are set to boolean True, need be just present,
                # with no argument.
                if value is not True:
                    yield str(value)

        self.arguments += args + tuple(generate_kwargs())
        return self

    def copy(self) -> 'Command':
        return type(self)(self.bin, *self.arguments)

    def __str__(self) -> str:
        return ' '.join([self.bin] + self.arguments)


class Rule:
    def __init__(self, targets: List[StrPath], sources: List[StrPath],
                 recipe: List[Command]) -> None:
        self.targets = targets
        self.sources = sources
        self.recipe = recipe

    @classmethod
    def creates(self, *items: StrPath) -> 'Rule':
        return Rule(targets=list(items), sources=[], recipe=[])

    def set_recipe(self, *commands: Command) -> 'Rule':
        self.recipe.extend(commands)
        return self

    def depends_on(self, *sources: StrPath) -> 'Rule':
        self.sources.extend(sources)
        return self

    def print(self) -> None:
        print(*self.targets, sep=' ', end=': ')
        print(*self.sources, sep=' ', end='\n')
        for command in self.recipe:
            print('\t', command, sep='', end='\n')


class PhonyRule(Rule):
    """
    A phony rule is always run, without checking its prerequisites.
    """
    def print(self) -> None:
        Rule.creates('.PHONY').depends_on(*self.targets).print()
        super().print()


class Makefile:
    """
    Context manager that allows one to define and print a Makefile.

    Usage:

    >>> cc = Command('$(CC)')
    >>> with Makefile() as make:
    ...     make.rule('target').depends_on('source_1', 'source_2').define_recipe(
    ...         cc(c=True, o='$@', '$^')
    ...     )
    target: source_1 source_2
            $(CC) -c -o $@ $^
    """

    def __init__(self) -> None:
        self.rules: List[Rule] = []
        self.phonies: List[PhonyRule] = []

    def __enter__(self) -> 'Makefile':
        return self

    def __exit__(self, exc_class, exc_inst, tb) -> None:
        # Print only if an error did not occur.
        if exc_class is None:
            self.print()

    def print(self) -> None:
        # Start off with a disclaimer.
        print("# Autogenerated file")
        print("# DO NOT MODIFY!")

        print()

        # Print the phony rules first.
        for phony in self.phonies:
            phony.print()

        print()

        # Print the "true" rules last.
        for rule in self.rules:
            rule.print()

    def rule(self, *targets) -> 'Rule':
        """
        Define a new rule in the Makefile.
        """
        rule = Rule.creates(*targets)
        self.rules.append(rule)
        return rule

    def phony_rule(self, name, *sources) -> 'PhonyRule':
        """
        Define a new phony rule; that is, a rule that runs regardless if its
        prerequisites are newer or not. This is useful for "command" targets,
        such as `make test` or `make install`.
        """
        rule = PhonyRule(targets=[name], sources=list(sources), recipe=[])
        self.phonies.append(rule)
        return rule
