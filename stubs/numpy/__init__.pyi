from typing import Any, Iterable, Iterator, NewType, Sequence, Sized, Tuple, TypeVar, Union
T = TypeVar('T')

class DataType(type):
    ...

Shape = Union[int, Sequence[int]]

bool = ...  # type: DataType
float32 = ...  # type: DataType
float64 = ...  # type: DataType

class ndarray(Sized, Iterable[T]):
    def __setitem__(self, *i: Any) -> None: ...
    def __getitem__(self, *i: Any) -> T: ...
    def __matmul__(self, other: ndarray) -> Union[ndarray[T], T]: ...
    def __add__(self, other: ndarray[T]) -> ndarray[T]: ...
    def __mul__(self, other: ndarray[T]) -> ndarray[T]: ...
    def __sub__(self, other: ndarray[T]) -> ndarray[T]: ...
    def __truediv__(self, other: T) -> ndarray[T]: ...
    def __iter__(self) -> Iterator[T]: ...
    def __len__(self) -> int: ...
    def argmax(self) -> int: ...
    def sum(self) -> float: ...

def array(object: Sequence, dtype: DataType=None) -> ndarray[T]: ...
def log(a: ndarray[T]) -> ndarray[T]: ...
def nextafter(a: T, b: T) -> T: ...
def ones(shape: Shape,  dtype: DataType=None) -> ndarray[T]: ...
def resize(a: ndarray[T], shape: Shape) -> ndarray[T]: ...
def where(cond, if_true: ndarray[T]=None, if_false: ndarray[T]=None) -> ndarray[T]: ...
def zeros(shape: Shape,  dtype: DataType=None) -> ndarray[T]: ...
